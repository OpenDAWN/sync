{"version":3,"file":"client/index.js","names":[],"mappings":"","sources":["client/index.es6.js"],"sourcesContent":["/**\n * @fileoverview Client side syncronization module\n * @author Sebastien.Robaszkiewicz@ircam.fr, Norbert.Schnell@ircam.fr\n */\n'use strict';\n\nvar audioContext = require('audio-context');\n\nfunction getMinOfArray(numArray) {\n  return Math.min.apply(null, numArray);\n}\n\nfunction getMaxOfArray(numArray) {\n  return Math.max.apply(null, numArray);\n}\n\nclass SyncProcess {\n  constructor(socket, iterations, period, statsCallback) {\n    this.id = Math.floor(Math.random() * 1000000);\n\n    this.socket = socket;\n    this.statsCallback = statsCallback;\n\n    this.iterations = iterations;\n    this.period = period;\n    this.count = 0;\n\n    this.timeOffsets = [];\n    this.travelTimes = [];\n    this.avgTimeOffset = 0;\n    this.avgTravelTime = 0;\n    this.minTravelTime = 0;\n    this.maxTravelTime = 0;\n\n    // Send first ping\n    this.__sendPing();\n\n    // When the client receives a 'pong' from the\n    // server, calculate the travel time and the\n    // time offset.\n    // Repeat as many times as needed (__iterations).\n    this.socket.on('sync_pong', (id, clientPingTime, serverPongTime) => {\n      if (id === this.id) {\n        var now = this.getLocalTime();\n        var travelTime = now - clientPingTime;\n        var timeOffset = serverPongTime - (now - travelTime / 2);\n\n        this.travelTimes.push(travelTime);\n        this.timeOffsets.push(timeOffset);\n\n        if (this.count < this.iterations) {\n          setTimeout(() => {\n            this.__sendPing();\n          }, 1000 * this.period);\n        } else {\n          this.avgTravelTime = this.travelTimes.reduce((p, q) => p + q) / this.travelTimes.length;\n          this.avgTimeOffset = this.timeOffsets.reduce((p, q) => p + q) / this.timeOffsets.length;\n          this.minTravelTime = getMinOfArray(this.travelTimes);\n          this.maxTravelTime = getMaxOfArray(this.travelTimes);\n\n          var stats = {\n            minTravelTime: this.minTravelTime,\n            maxTravelTime: this.maxTravelTime,\n            avgTravelTime: this.avgTravelTime,\n            avgTimeOffset: this.avgTimeOffset\n          };\n\n          this.socket.emit('sync_stats', stats);\n          statsCallback(stats);\n        }\n      }\n    });\n  }\n\n  __sendPing() {\n    this.count++;\n    this.socket.emit('sync_ping', this.id, audioContext.currentTime);\n  }\n}\n\nclass SyncClient {\n  constructor(params = {}) {\n    this.iterations = params.iterations || 5;\n    this.period = params.period || 0.500;\n    this.minInterval = this.minInterval || 10;\n    this.maxInterval = this.maxInterval || 20;\n\n    if(this.minInterval > this.maxInterval)\n      this.minInterval = this.maxInterval;\n\n    // stats\n    this.minTravelTimes = [];\n    this.maxTravelTimes = [];\n    this.avgTravelTimes = [];\n    this.avgTimeOffsets = [];\n\n    this.timeOffset = 0;\n  }\n\n  start(socket, statsCallback) {\n    this.socket = socket;\n    this.statsCallback = statsCallback;\n    this.__syncLoop();\n  }\n\n  __syncLoop() {\n    var interval = this.minInterval + Math.random() * (this.maxInterval - this.minInterval);\n\n    var sync = new SyncProcess(this.socket, this.iterations, this.period, (stats) => {\n      this.timeOffset = stats.avgTimeOffset;\n\n      this.minTravelTimes.push(stats.minTravelTime);\n      this.maxTravelTimes.push(stats.maxTravelTime);\n      this.avgTimeOffsets.push(stats.avgTimeOffset);\n      this.avgTravelTimes.push(stats.avgTravelTime);\n\n      this.statsCallback(stats);\n    });\n\n    setTimeout(() => {\n      this.__syncLoop();\n    }, 1000 * interval);\n  }\n\n  getLocalTime(serverTime) {\n    if (serverTime)\n      return serverTime - this.timeOffset;\n\n    return audioContext.currentTime;\n  }\n\n  getServerTime(localTime = audioContext.currentTime) {\n    return localTime + this.timeOffset;\n  }\n}\n\nmodule.exports = SyncClient;\n"],"sourceRoot":"/source/"}